<html>
<head>
	<title>atomicGL DEBUG </title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

	<script type="text/javascript" src="gltp1_fichiers/glMatrix-0.js"></script>
	<script type="text/javascript" src="gltp1_fichiers/webgl-utils.js"></script>

	<!-- ATOMICGL ENGINE -->
	<!-- load "modules" -->
	<script type="text/javascript" src="atomicGLContext.js"></script>
	<script type="text/javascript" src="atomicGLMatrixStack.js"></script>
	
	<script type="text/javascript" src="atomicGLClock.js"></script>

	<script type="text/javascript" src="atomicGLShader.js"></script>
	<script type="text/javascript" src="atomicGLwaveShader.js"></script>

	<script type="text/javascript" src="atomicGLCube.js"></script>
	<script type="text/javascript" src="atomicGLxyPlane.js"></script>
	<script type="text/javascript" src="atomicGLxzPlane.js"></script>
	<script type="text/javascript" src="atomicGLSphere.js"></script>





<script id="vertex_GodRay" type="x-shader/x-vertex">
	// vertex shader
	

	float4 main(float2 textCoord : TEXTCOORD0) : COLOR0 {
	
		//Calculate vector from pixel to light source in screen space
		half2 deltaTextCoord = (texCoord - ScreenLightPos.xy);
		//Divide by number of samples and scale by control factor
		deltaTexCoord *= 1.0f / NUM_SAMPLES * Density;
		//Store initial sample
		half3 color = tex2D(frameSampler, texCoord);
		//Set up illumination decay factor
		half illuminationDecay = 1.0f;
		//Evaluate Summation from Equation 3 NUM_SAMPLES iterations
		for (int i = 0; i < NUM_SAMPLES; i++)
		{
			//Step sample location along ray
			texCoord -= deltaTexCoord;
			//Retrieve sample at new location
			half3 sample = tex2D(frameSampler, texCoord);
			//Apply sample attenuation scale/decay factors
			sample *= illuminationDecay * Weight;
			//Accumulate combined color
			color += sample;
			//Update exponential decay factor
			illuminationDecay *= Decay;
		}
		//Output final color with a further scale control factor
		return float4(color * Exposure, 1);
	}
</script>
	<script id="frag_GodRay" type="x-shader/x-fragment">
	/* 
If you think this shader is an useful example, 
please like it :-)

reference:
https://www.shadertoy.com/view/Mdl3Rr

change log:
- 2013-04-10 initial release
*/

#define LIGHT_ANIMATION
//#define LOW_QUALITY		// uncomment this if this shader runs too slow on your PC
//#define ULTRA_QUALITY 	// uncomment this if you have a really fast GPU :-)
#define SMOKE				// comment this if you think the smoke effect is too annoying

float gAnimTime = iGlobalTime * 0.5;

struct Ray
{
	vec3 org;
	vec3 dir;
};
	
float hash (float n)
{
	return fract(sin(n)*43758.5453);
}

float noise (in vec3 x)
{
	vec3 p = floor(x);
	vec3 f = fract(x);

	f = f*f*(3.0-2.0*f);

	float n = p.x + p.y*57.0 + 113.0*p.z;

	float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
						mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
					mix(mix( hash(n+113.0), hash(n+114.0),f.x),
						mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
	return res;
}

float udRoundBox( in vec3 p, in vec3 b, in float r )
{
	return length(max(abs(p)-b,0.0))-r;
}

float sdPlane( in vec3 p, in vec4 n )
{
	// n must be normalized
	return dot( p, n.xyz ) + n.w;
}

float opU( in float d1, in float d2 )
{
	return min(d1,d2);
}

vec3 translate( in vec3 v, in vec3 t )
{
	return v - t;
}

float scene( in vec3 pos )
{
	vec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d
	
	vec4 boxd1 = vec4( 0.5, 3.5, 0.5, 0.25 ); // sxyz, r
	vec4 boxp1 = vec4( 0.0, 3.5, 0.0, 0.0 ); // xyz, 0
	boxd1.xyz -= boxd1.w;
	
	vec4 boxd2 = vec4( 3.0, 0.5, 0.5, 0.25 ); // sxyz, r
	vec4 boxp2 = vec4( 0.0, 4.5, 0.0, 0.0 ); // xyz, 0
	boxd2.xyz -= boxd2.w;
	
	
	float d = 99999.0;
	
	d = opU( d, udRoundBox( translate( pos, boxp1.xyz ), boxd1.xyz, boxd1.w ) );
	d = opU( d, udRoundBox( translate( pos, boxp2.xyz ), boxd2.xyz, boxd2.w ) );
	d = opU( d, sdPlane( pos, plane ) );
	
	return d;
}

vec3 sceneNormal( in vec3 pos )
{
    vec3 eps = vec3( 0.001, 0.0, 0.0 );
	vec3 nor;
	nor.x = scene( pos + eps.xyy ) - scene( pos - eps.xyy );
	nor.y = scene( pos + eps.yxy ) - scene( pos - eps.yxy );
	nor.z = scene( pos + eps.yyx ) - scene( pos - eps.yyx );
	return normalize( nor );
}

bool raymarch( in Ray ray, in int maxSteps, out vec3 hitPos, out vec3 hitNrm )
{
	const float hitThreshold = 0.0001;

	bool hit = false;
	hitPos = ray.org;

	vec3 pos = ray.org;

	for ( int i = 0; i < 256; i++ )
	{
		if ( i >= maxSteps )
			break;
		float d = scene( pos );

		if ( d < hitThreshold )
		{
			hit = true;
			hitPos = pos;
			hitNrm = sceneNormal( pos );
			break;
		}
		pos += d * ray.dir;
	}
	return hit;
}

#ifdef LOW_QUALITY
#define INSCATTER_STEPS 24
#else
#	ifdef ULTRA_QUALITY
#define INSCATTER_STEPS 64
#	else
#define INSCATTER_STEPS 48
#	endif
#endif


float raySphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )
{
	vec3 oc = ro - sph.xyz; // looks like we are going place sphere from an offset from ray origin, which is = camera
	float b = 2.0 * dot( oc, rd );
	float c = dot( oc, oc ) - sph.w * sph.w; // w should be size
	float h = b * b - 4.0 * c;
	if ( h < 0.0 )
	{
		return -10000.0;
	}
	float t = (-b - sqrt(h)) / 2.0;
	
	return t;
}

vec3 inscatter( in Ray rayEye, in vec4 light, in vec3 screenPos, in float sceneTraceDepth )
{
	vec3 rayEeyeNDir = normalize( rayEye.dir );
	
	// the eye ray does not intersect with the light, so skip computing
	if ( raySphereIntersect( rayEye.org, rayEeyeNDir, light ) < -9999.0 )
		return vec3( 0.0 );
	
	float scatter = 0.0;
	float invStepSize = 1.0 / float( INSCATTER_STEPS );
	
	vec3 hitPos, hitNrm;
	vec3 p = rayEye.org;
	vec3 dp = rayEeyeNDir * invStepSize * sceneTraceDepth;
	
	// apply random offset to minimize banding artifacts.
	p += dp * noise( screenPos ) * 1.5;
	
	for ( int i = 0; i < INSCATTER_STEPS; ++i )
	{
		p += dp;
		
		Ray rayLgt;
		rayLgt.org = p;
		rayLgt.dir = light.xyz - p;
		float dist2Lgt = length( rayLgt.dir );
		rayLgt.dir /= 8.0;
		
		float sum = 0.0;
		if ( !raymarch( rayLgt, 16, hitPos, hitNrm ) )
		{
			// a simple falloff function base on distance to light
			float falloff = 1.0 - pow( clamp( dist2Lgt / light.w, 0.0, 1.0 ), 0.125 );
			sum += falloff;
			
#ifdef SMOKE
			float smoke = noise( 1.25 * ( p + vec3( gAnimTime, 0.0, 0.0 ) ) ) * 0.375;
			sum += smoke * falloff;
#endif
		}
		
		scatter += sum;
	}
	
	scatter *= invStepSize; // normalize the scattering value
	scatter *= 8.0; // make it brighter
	
	return vec3( scatter );
}

float softshadow( in Ray ray, in float mint, in float maxt, in float k )
{
	float t = mint;
	float res = 1.0;
    for ( int i = 0; i < 128; ++i )
    {
        float h = scene( ray.org + ray.dir * t );
        if ( h < 0.001 )
            return 0.0;
		
		res = min( res, k * h / t );
        t += h;
		
		if ( t > maxt )
			break;
    }
    return res;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;
	float aspectRatio = iResolution.x / iResolution.y;
	
	// camera XYZ in world space
	vec3 camWsXYZ = vec3( 0.0, 3.0, 5.0 );
	
	// construct the ray in world space
	Ray ray;
	ray.org = camWsXYZ;
	ray.dir = vec3( ndcXY * vec2( aspectRatio, 1.0 ), -1.0 ); // OpenGL is right handed
	
	// define the point light in world space (XYZ, range)
	vec4 lightWs = vec4( 0.0, 4.5, -4.0, 10.0 );
#ifdef LIGHT_ANIMATION
	lightWs.x += sin( gAnimTime ) * 2.0;
	lightWs.y += cos( gAnimTime ) * 2.0;
#endif
	
	vec3 sceneWsPos;
	vec3 sceneWsNrm;
	
	vec4 c = vec4( 0.0 );
	
	if ( raymarch( ray, 128, sceneWsPos, sceneWsNrm ) )
	{
		// apply simple depth fog
		float viewZ = sceneWsPos.z - camWsXYZ.z;
		float fog = clamp( ( viewZ + 20.0 ) / 5.0 , 0.0, 1.0 );
		fog = fog * fog;
		c.rgb = vec3( 0.125 * fog );
	}
	
	// apply scattering of the
	c.rgb += inscatter( ray, lightWs, vec3( fragCoord.xy, 0.0 ), 12.0 );
	
	// color correction - Sherlock color palette
	c.r = smoothstep( 0.0, 1.0, c.r );
	c.g = smoothstep( 0.0, 1.0, c.g - 0.1 );
	c.b = smoothstep(-0.3, 1.3, c.b );
	
	fragColor = c;
}

</script>

	<!-- SHADER: vertex color -->
	<!-- display the color of the  object -->
	<script id="vertex_vertex-color" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// vertex color
	// ------------------------------------------------------

	// attributes inputs 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec3 aVertexColor;

	// uniform matrices
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform mat3 uNMatrix;

	// uniform ambiant color
	uniform vec3 uAmbientColor;

	// output (to fragment shader)
	varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * mvPosition;
		
		// vcolor
		vcolor = uAmbientColor+aVertexColor;
	}
</script>
	<script id="frag_vertex-color" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// vertex color
	// ------------------------------------------------------

	// varying input
	varying vec3 vcolor;

	// main
	void main(void) { gl_FragColor = vec4(vcolor, 1.0);}

</script>

	<!-- SHADER: diffus per fragment -->
	<!-- diffuse shader -->
	<script id="vertex_diffuse" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
</script>
<script id="frag_diffuse" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
			
		// light color
         vec3 lightColor = uAmbientColor + Kd*diffuseLightWeight*uPointLightColor0 *vcolor  ;

        gl_FragColor = vec4(lightColor,1.0);
    }
</script>

	<!-- SHADER: wave vertex -->
	<!-- wave shader -->
	<script id="vertex_wave" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// wave vertex shader
	// sum of 4 sin waves
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform waves
	// A sin(w*u + p*t)
	// [0]: A amplitude
	// [1]: w omega
	// [2]: p phi
		uniform vec3 uA0 ;
		uniform vec3 uA1 ;
		uniform vec3 uA2 ;
		uniform vec3 uA3 ;

	// uniform
		uniform vec2 uXrange;
		
	// uniform time
		uniform float utime ;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		float u = (aVertexPosition.x - uXrange.x)/(uXrange.y -uXrange.x)*6.28 ;
		float wupt0 = uA0.y*u+uA0.z*utime ;
		float wupt1 = uA1.y*u+uA1.z*utime ;
		float wupt2 = uA2.y*u+uA2.z*utime ;
		float wupt3 = uA3.y*u+uA3.z*utime ;
		// Asin
		float Asin0 = uA0.x*sin(wupt0);
		float Asin1 = uA1.x*sin(wupt1);
		float Asin2 = uA2.x*sin(wupt2);
		float Asin3 = uA3.x*sin(wupt3);
		
		float dy = Asin0 +Asin1 +Asin2 +Asin3 ;
		// tangent
		float tx =1.0;
		float ty0 = uA0.x*6.28*uA0.y*cos(wupt0)/(uXrange.y -uXrange.x);
		float ty1 = uA1.x*6.28*uA1.y*cos(wupt1)/(uXrange.y -uXrange.x);
		float ty2 = uA2.x*6.28*uA2.y*cos(wupt2)/(uXrange.y -uXrange.x);
		float ty3 = uA3.x*6.28*uA3.y*cos(wupt3)/(uXrange.y -uXrange.x);
		float ty = ty0 + ty1 + ty2+ ty3;
		float tz =0.0 ;
		// normal
		vec3 dnormal= normalize(vec3(-ty,tx,tz));
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition+vec3(0.0,dy,0.0), 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * (vec3(vNormal.x,0.0,vNormal.z)+dnormal);	
		// vcolor
		vcolor = aVertexColor;
	}
</script>

	<!-- ATOMICGL ENGINE -->
	<!-- create objects -->
	<!-- wegGLStart function (required) -->
	<script type="text/javascript">
	//------------------------------------------------------------------------------

	// OpenGL context
	var agl = new atomicGLContext();
	
	// clock
	var sceneClock =new atomicGLClock() ;

	// matrix stack
	var ams =new atomicGLMatrixStack();

	// shader and id
	// vertex color
	var vertexColorProg ;
	var vertexColorProgId ;
	// diffus
	var diffusProg ;
	var diffusProgId ;
	// wave
	var waveProg ;
	var waveProgId ;


	// cube
	var cube 		= new atomicGLCube("firstCube",5, 1,1) ;
	var colorcube 	= new atomicGLCube("colorcube",1, 1,1) ;
	var back		= new atomicGLxyPlane("firstPlane",5,10,2,2); 
	var floor		= new atomicGLxzPlane("floor",10,50,200,2); 
	var sphere 		= new atomicGLSphere("sphere",0.5,64,64);
	
	// animation
	var colorCubeYangle = 0.0 ;
	var waveTime = 0.0 ;
	

	//webGLStart
	function webGLStart() {
	// init
	// -----------------------------
		// recover penGL canvas 
		var canvas = document.getElementById("oglcanvas");

		// init OpenGL context
		agl.initGL(canvas,[0.0,0.0,0.0]);
		
		// light
		agl.pushLight([5.0,5.0,-10.0],[1.0,1.0,1.0]); // position, color
		//agl.ambientLightColor = [0.01,0.01,0.2];	// color

		// init Matrix Stack
		ams.initMatrix(agl,45); // fov = 45 degrees

		// load shaders
		vertexColorProg = new atomicGLShader("color", agl,"frag_vertex-color", "vertex_vertex-color" ,false,0);
		diffusProg 		= new atomicGLShader("diffus", agl,"frag_diffuse", "vertex_diffuse" ,false,1);
		
	//vertexGodRayProg = new atomicGLShader("godRay", agl,"frag_GodRay", "vertex_GodRay" ,false,0);



		waveProg 		= new atomicGLwaveShader("wave", agl,"frag_diffuse", "vertex_wave" ,false,1);
		waveProg.A0 = [0.50,1.0,1.0];
		waveProg.A1 = [0.50,2.0,1.0]; 
		waveProg.A2 = [0.20,3.0,1.0]; 
		waveProg.A3 = [0.20,4.0,1.0]; 
		waveProg.xRange = [-5.0,5.0]; 
		// wave animation 
		waveProg.wTime = 0.0 ;	

		// push shader in context
		vertexColorProgId 	= agl.pushProgram(vertexColorProg);
		diffusProgId 		= agl.pushProgram(diffusProg);
		waveProgId 			= agl.pushProgram(waveProg);
	
		//GodRayProg Id 	= agl.pushProgram(vertexGodRayProg);

	





		// cube color & init
		colorcube.setFaceColor("Front",[1.0,0.0,0.0]) ;
		colorcube.setFaceColor("Back", [1.0,0.0,0.0]) ;
		colorcube.setFaceColor("Left", [0.0,1.0,0.0]) ;
		colorcube.setFaceColor("Right",[0.0,1.0,0.0]) ;
		colorcube.setFaceColor("Top",  [0.0,0.0,1.0]) ;
		colorcube.setFaceColor("Bottom",[0.0,0.0,1.0]) ;
		colorcube.initGLBuffers(agl);

		// cube color & init
		cube.setFaceColor("All",[1.0,1.0,1.0]) ;
		cube.initGLBuffers(agl);

		// plane color & init
		back.setFaceColor("All",[1.0,1.0,1.0]) ;
		back.initGLBuffers(agl);	
		
		// floor color & init
		floor.setFaceColor("All",[0.4,0.5,0.8]) ;
		floor.initGLBuffers(agl);

		// sphere
		sphere.setFaceColor("All",[1.0,1.0,1.0]);
		sphere.initGLBuffers(agl);
	
		// start the animation
		nextFrame();
	}
		
	// draw
	// -----------------------------
	function sceneDraw(){
		agl.initDraw();

		// global transform
		// ------------------------------
		// push matrix
		ams.mvPushMatrix();
		// position & orientation	

			ams.mvTranslate(0,-2,-20);
			ams.mvRotate(20,[1,0,0]);
			//ams.mvTranslate(0,-15,-30);
		

		/*	// plane (background)
			// ------------------------------
			// push matrix
			ams.mvPushMatrix();
				// position & orientation	
				ams.mvTranslate(0,0,-5);
				// draw
				back.draw(agl,ams,diffusProgId);
			// pop matrix
			ams.mvPopMatrix();	*/
		
		/*	// floor
			// ---------------------------------
			// push matrix
			ams.mvPushMatrix();
			// position & orientation
				ams.mvTranslate(0.0,0.0,0.0);
				// draw
				floor.draw(agl,ams,waveProgId);
			// pop matrix
			ams.mvPopMatrix();
			*/
			// colorcube
			// ---------------------------------
			/*// push matrix
			ams.mvPushMatrix();
			// position & orientation
				ams.mvTranslate(-2.0,0,0);
				ams.mvRotate(colorCubeYangle,[0,1,0]);
				// draw
				colorcube.draw(agl,ams,vertexColorProgId);
			// pop matrix
			ams.mvPopMatrix();*/

			/*// cube
			// ---------------------------------
			// push matrix
			ams.mvPushMatrix();
			// position & orientation
				ams.mvTranslate(2.0,-2.50,0);
				ams.mvRotate(-30,[0,1,0]);
				// draw
				cube.draw(agl,ams,diffusProgId);
			// pop matrix
			ams.mvPopMatrix();*/
		
			// sphere
			// ---------------------------------------
			// push matrix
			ams.mvPushMatrix();
				// position & orientation
				ams.mvTranslate(0.0,0.5,0);
				// draw
				sphere.draw(agl,ams,diffusProgId);
			// pop matrix
			ams.mvPopMatrix();
			
		// ---------------------------------------	
		// pop matrix
		ams.mvPopMatrix();
	}
	
	// nextFrame
	// -----------------------------
    function nextFrame() {
        requestAnimFrame(nextFrame);
        sceneDraw();
        animate();
    }
    
    // animate
    // ------------------------------
    function animate(){
    	// increase time
    	sceneClock.tick() ;
    	colorCubeYangle = colorCubeYangle + 0.1*sceneClock.get();
    	waveTime = waveTime + 0.005*sceneClock.get();
    	waveProg.wTime = waveTime ;
    }

</script>
</head>

<body onload="webGLStart();">
	<br>
    <canvas id="oglcanvas" style="border: none;" width="800" height="600"></canvas>
	<br>
</body></html>