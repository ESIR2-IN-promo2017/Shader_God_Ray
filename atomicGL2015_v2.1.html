<html>
<head>
	<title>atomicGL DEBUG </title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

	<script type="text/javascript" src="gltp1_fichiers/glMatrix-0.js"></script>
	<script type="text/javascript" src="gltp1_fichiers/webgl-utils.js"></script>

	<!-- ATOMICGL ENGINE -->
	<!-- load "objects" -->
	<script type="text/javascript" src="objs/palais_v01_bois_parquet.js"></script>
	<script type="text/javascript" src="objs/palais_v01_bois_poutre.js"></script>
	<script type="text/javascript" src="objs/palais_v01_decors.js"></script>
	<script type="text/javascript" src="objs/palais_v01_mur.js"></script>
	<script type="text/javascript" src="objs/palais_v01_terrase.js"></script>
	<script type="text/javascript" src="objs/palais_v01_toiture.js"></script>
	
	<script type="text/javascript" src="objs/donjonBase.js"></script>
	<script type="text/javascript" src="objs/donjonBois.js"></script>
	<script type="text/javascript" src="objs/donjonFenetre.js"></script>
	<script type="text/javascript" src="objs/donjonMur.js"></script>
	<script type="text/javascript" src="objs/donjonSol.js"></script>
	<script type="text/javascript" src="objs/donjonToiture.js"></script>

	<script type="text/javascript" src="objs/maison1mur.js"></script>
	<script type="text/javascript" src="objs/maison1sol.js"></script>
	<script type="text/javascript" src="objs/maison1stone.js"></script>
	<script type="text/javascript" src="objs/maison1stone2.js"></script>
	<script type="text/javascript" src="objs/maison1toit.js"></script>
	<script type="text/javascript" src="objs/maison1wood.js"></script>

	<script type="text/javascript" src="objs/maison3.js"></script>
	<script type="text/javascript" src="objs/maison3roof.js"></script>
	<script type="text/javascript" src="objs/maison3wood.js"></script>
	
	<script type="text/javascript" src="objs/sol_herbe.js"></script>
	<script type="text/javascript" src="objs/sol_route.js"></script>
	<script type="text/javascript" src="objs/sol_muret.js"></script>
	<script type="text/javascript" src="objs/sol_sable.js"></script>

	<script type="text/javascript" src="objs/pont_dessus.js"></script>
	<script type="text/javascript" src="objs/pont_pierre.js"></script>
	
	<script type="text/javascript" src="objs/tour1base.js"></script>
	<script type="text/javascript" src="objs/tour1mur.js"></script>
	<script type="text/javascript" src="objs/tour1parape.js"></script>
	<script type="text/javascript" src="objs/tour1sol.js"></script>
	<script type="text/javascript" src="objs/tour1toit.js"></script>

	<script type="text/javascript" src="objs/mur2base.js"></script>
	<script type="text/javascript" src="objs/mur2pierre.js"></script>
	<script type="text/javascript" src="objs/mur2bois.js"></script>
	<script type="text/javascript" src="objs/mur2toit.js"></script>
	
	<!-- load "modules" -->
	<script type="text/javascript" src="atomicGLContext.js"></script>
	<script type="text/javascript" src="atomicGLMatrixStack.js"></script>
	<script type="text/javascript" src="atomicGLTexture.js"></script>
	
	<script type="text/javascript" src="atomicGLClock.js"></script>
	<script type="text/javascript" src="atomicGLWalkCamera.js"></script>

	<script type="text/javascript" src="atomicGLShader.js"></script>
	<script type="text/javascript" src="atomicGLwaveShader.js"></script>

	<script type="text/javascript" src="atomicGLObj.js"></script>
	<script type="text/javascript" src="atomicGLCube.js"></script>
	<script type="text/javascript" src="atomicGLSkyBox.js"></script>
	<script type="text/javascript" src="atomicGLxyPlane.js"></script>
	<script type="text/javascript" src="atomicGLxzPlane.js"></script>
	<script type="text/javascript" src="atomicGLSphere.js"></script>
	<script type="text/javascript" src="atomicGLCylinder.js"></script>

	<!-- SHADER: vertex color -->
	<!-- display the color of the  object -->
	<script id="vertex_vertex-color" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// vertex color
	// ------------------------------------------------------

	// attributes inputs 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec3 aVertexColor;

	// uniform matrices
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform mat3 uNMatrix;

	// uniform ambiant color
	uniform vec3 uAmbientColor;

	// output (to fragment shader)
	varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * mvPosition;
		
		// vcolor
		vcolor = uAmbientColor+aVertexColor;
	}
</script>
	<script id="frag_vertex-color" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// vertex color
	// ------------------------------------------------------

	// varying input
	varying vec3 vcolor;

	// main
	void main(void) { gl_FragColor = vec4(vcolor, 1.0);}

</script>

	<!-- SHADER: diffus per fragment -->
	<!-- diffuse shader -->
	<script id="vertex_diffuse" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
</script>
	<script id="frag_diffuse" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
			
		// light color
         vec3 lightColor = uAmbientColor + Kd*diffuseLightWeight*uPointLightColor0 *vcolor  ;

        gl_FragColor = vec4(lightColor,1.0);
    }
</script>

	<!-- SHADER: phong per fragment -->
	<!-- phong shader -->
	<script id="vertex_phong" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// phong shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
	</script>
	<script id="frag_phong" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// phong shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant
		// Kd: diffuse coeff
		float Kd = 0.5 ;
		float Ks = 0.5 ;
		float sh = 8.0 ;
		// specular color
		vec3 specColor = vec3(1.0,1.0,1.0);
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		
		// reflection direction
		vec3 reflectDirection = normalize(reflect(-lightDirection,normal));
		
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
			
		// specular term
		float specularLightWeight = pow(max(dot(reflectDirection,eyeDirection),0.0),sh);
			
		// light color
         vec3 lightColor = uAmbientColor + Kd*diffuseLightWeight*uPointLightColor0 *vcolor + Ks*specularLightWeight*uPointLightColor0*specColor ;

        gl_FragColor = vec4(lightColor,1.0);
    }
	</script>	
	
	<!-- SHADER: cartoon per fragment -->
	<!-- cartoon shader -->
	<script id="vertex_cartoon" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// cartoon shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
	</script>
	<script id="frag_cartoon" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// cartoon shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;

	// local constant - could be uniform
		// edge color
		vec3 edgeColor = vec3(0.0,0.0,0.0);
		// shadow color
		vec3 shadowColor = vec3(0.0, 0.0, 0.5);
		// midtoneColor
		vec3 midtoneColor = vec3(0.0,0.0,1.0);
		// highlight color
		vec3 highLightColor = vec3(1.0,1.0, 1.0);
		// diffuse scpecular shininess
		float Kd = 0.5 ;
		float Ks = 0.5 ;
		float sh = 8.0 ;
		// thresholds
		float shadowMidtone = 0.0;
		float midToneHighLight = 0.75 ;
		float edgeThreshold = 0.95 ; 
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		
		// reflection direction
		vec3 reflectDirection = normalize(reflect(-lightDirection,normal));
		
		//  diffuse term
		float diffuse = max(dot(normal, lightDirection), 0.0);
			
		// specular term
		float specular = pow(max(dot(reflectDirection,eyeDirection),0.0),sh);
		
		// light
		float light = Kd*diffuse + Ks*specular;
		
		// edge term
		float edge = sqrt(1.0 - pow(max(dot(normal,eyeDirection),0.0),2.0));
			
		// color
         vec3 final = vec3(1.0,0.0,0.0);
         if (edge > edgeThreshold)			
         	{ final = edgeColor;}
         else if (light <= shadowMidtone) 	
         	{ final = shadowColor;}
         else if (light <= midToneHighLight)
         	{ final = midtoneColor;}
         else 								
         	{ final = highLightColor;}

        gl_FragColor = vec4(final,1.0);
    }
	</script>	

	<!-- SHADER: texture per fragment -->
	<!-- texture shader -->
	<script id="vertex_texture" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal ;
		attribute vec2 aVertexTexCoord;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

    void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// texCoord
        vTextureCoord = aVertexTexCoord;
    }
	</script>
	<script id="frag_texture" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif
	// fragment shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------

    varying vec2 vTextureCoord;
    uniform sampler2D uSampler0;

    void main(void) {
        gl_FragColor = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
    }
	</script>

	
	<!-- SHADER: textureDiff -->
	<!-- texture diffus shader -->
	<script id="vertex_texDiff" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec2 aVertexTexCoord;
		attribute vec3 aVertexNormal;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

    void main(void) {
    	// vNormal
		vNormal = uNMatrix * aVertexNormal;	
    
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aVertexTexCoord;
    }
	</script>
	<script id="frag_texDiff" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif
	// fragment shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;	
		
	// inputs
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;
    	
    // Uniform
    	uniform sampler2D uSampler0;
    	
		// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;


    void main(void) {
    	// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);

		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
		
		// texture color
		vec4 texColor  = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
			
		// light color
		vec3 lightColor = Kd*uAmbientColor*texColor.rgb + Kd*diffuseLightWeight*uPointLightColor0 *texColor.rgb ;



        gl_FragColor = vec4(lightColor,1.0);
    }
	</script>
	
	<!-- SHADER: texture Diffus & normal map -->
	<!-- texture diffus and normal mapshader -->
	<script id="vertex_texDiffNormalMap" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec2 aVertexTexCoord;
		attribute vec3 aVertexNormal;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;

    void main(void) {
    	// vNormal
		vNormal = uNMatrix * aVertexNormal;	
    
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aVertexTexCoord;
    }
	</script>
	<script id="frag_texDiffNormalMap" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif
	// fragment shader
	// ------------------------------------------------------
	// texture shader per fragment 
	// ------------------------------------------------------
	// lights nb: 1
	// ------------------------------------------------------
	
	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;	
		
	// inputs
    	varying vec2 vTextureCoord;
		varying vec4 vPosition;
		varying vec3 vNormal;
    	
    // Uniform
    	uniform sampler2D uSampler0;
    	uniform sampler2D uSampler1;
    	
		// lights
		// ambient
		uniform vec3 uAmbientColor;

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;


    void main(void) {
    	// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);
		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 oldNormal = normalize(vNormal);
		// new normal in tangent space
		vec3 newNormalTS = normalize(2.0*texture2D(uSampler1, vTextureCoord).xyz -1.0) ;
		//newNormalTS.z = newNormalTS.z*1000.0;
		// newNormalTS = normalize(newNormalTS);
		// TS to View
		vec3 biTangent = cross(oldNormal,vec3(0.0,0.0,1.0));
		// test tangent
		if (dot(biTangent,biTangent) == 0.0){biTangent = cross(oldNormal,vec3(0.0,1.0,0.0));}
		vec3 tangent =  cross(biTangent,oldNormal);
		// no transpose
		vec3 u1 = tangent ;
		vec3 u2 = biTangent;
		vec3 u3 = oldNormal;		
		// TS to view matrix
		mat3 TBN = mat3(u1,u2,u3);
		// transform normal
		vec3 normal = TBN*newNormalTS ;
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
		
		// texture color
		vec4 texColor  = texture2D(uSampler0, vec2(vTextureCoord.s, vTextureCoord.t));
			
		// light color
		vec3 lightColor = Kd*uAmbientColor*texColor.rgb + Kd*diffuseLightWeight*uPointLightColor0 *texColor.rgb ;



        gl_FragColor = vec4(lightColor,1.0);
    }
	</script>

	
	<!-- SHADER: wave vertex -->
	<!-- wave shader -->
	<script id="vertex_wave" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// wave vertex shader
	// sum of 4 sin waves
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec2 aVertexTexCoord;
		
	// uniform waves
	// A sin(w*u + p*t)
	// [0]: A amplitude
	// [1]: w omega
	// [2]: p phi
		uniform vec3 uA0 ;
		uniform vec3 uA1 ;
		uniform vec3 uA2 ;
		uniform vec3 uA3 ;

	// uniform
		uniform vec2 uXrange;
		
	// uniform time
		uniform float utime ;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		varying vec2 vTextureCoord;

	void main(void) {
		float u = (aVertexPosition.x - uXrange.x)/(uXrange.y -uXrange.x)*6.28 ;
		float wupt0 = uA0.y*u+uA0.z*utime ;
		float wupt1 = uA1.y*u+uA1.z*utime ;
		float wupt2 = uA2.y*u+uA2.z*utime ;
		float wupt3 = uA3.y*u+uA3.z*utime ;
		
		// Asin
		float Asin0 = uA0.x*sin(wupt0);
		float Asin1 = uA1.x*sin(wupt1);
		float Asin2 = uA2.x*sin(wupt2);
		float Asin3 = uA3.x*sin(wupt3);
		
		float dy = Asin0 +Asin1 +Asin2 +Asin3 ;
		
		// tangent
		float tx =1.0;
		float ty0 = uA0.x*6.28*uA0.y*cos(wupt0)/(uXrange.y -uXrange.x);
		float ty1 = uA1.x*6.28*uA1.y*cos(wupt1)/(uXrange.y -uXrange.x);
		float ty2 = uA2.x*6.28*uA2.y*cos(wupt2)/(uXrange.y -uXrange.x);
		float ty3 = uA3.x*6.28*uA3.y*cos(wupt3)/(uXrange.y -uXrange.x);
		float ty = ty0 + ty1 + ty2+ ty3;
		float tz =0.0 ;
		
		// normal
		vec3 dnormal= normalize(vec3(-ty,tx,tz));
		
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition+vec3(0.0,dy,0.0), 1.0);
		gl_Position = uPMatrix * vPosition;
		
		// vNormal
		vNormal = uNMatrix * (vec3(vNormal.x,0.0,vNormal.z)+dnormal);	
		
		// vTextureCoord
		vTextureCoord = aVertexTexCoord;
	}
</script>

	<!-- ATOMICGL ENGINE -->
	<!-- create objects -->
	<!-- wegGLStart function (required) -->
	<script type="text/javascript">
	//------------------------------------------------------------------------------
	// for mouse
	var windowHalfX = window.innerWidth / 2;
	var windowHalfY = window.innerHeight / 2;
	var mouseX = 0.0;
	var mouseY = 0.0;
	document.onmousemove = onDocumentMouseMove;

	var currentlyPressedKeys = {};
	//	keyboard callbacks 
	document.onkeydown = handleKeyDown;
	document.onkeyup = handleKeyUp;		

	// camera
	var cam = new atomicGLWalkCamera();
	// OpenGL context
	var agl = new atomicGLContext();	
	// clock
	var sceneClock =new atomicGLClock() ;
	// matrix stack
	var ams =new atomicGLMatrixStack();
	
	// texture
		var test, test_normal;
		var mur_pierre1, mur_pierre1_normal;
		var mur2, mur2_normal;
		var mur3, mur3_normal;
		var toit1, toit1_normal;
		var bois1;
		var pave2, pave2_normal;
		var pierre2, pierre2_normal;
		var pierre3, pierre3_normal;
		var sol3;
		var eau1;
		var marbre1;
		var bois2;
		var sol5;
		var sol4, sol4_normal;		
		var toit2, toit2_normal;
		var sable1 ;
		var herbe1 ;
		var skyTex ;

	// scene
	// -------------------------------------------------
	var sky = new atomicGLSkyBox('sky',800.0);
	
	var ground_grass = new atomicGLObj('solherbe', 		new sol_herbe(),		0.1,0.1) ;
	var ground_road  = new atomicGLObj('solroute', 		new sol_route(),		0.5,0.5) ;
	var ground_wall  = new atomicGLObj('solmuret', 		new sol_muret(),		1.0,1.0) ;
	var ground_sand  = new atomicGLObj('solsable', 		new sol_sable(),		0.1,0.1) ;
				
	var house3 		= new atomicGLObj('maison3', 		new maison3(),		1.0,1.0) ;
	var house3roof 	= new atomicGLObj('maison3roof', 	new maison3roof(),	1.0,1.0) ;
	var house3wood 	= new atomicGLObj('maison3wood', 	new maison3wood(),	1.0,1.0) ;
	
	var bridge1stone= new atomicGLObj('bridge1stone', 	new pont_pierre(),	1.0,1.0) ;
	var bridge1top 	= new atomicGLObj('bridge1top', 	new pont_dessus(),	0.1,0.1) ;
	
	var tower1base	= new atomicGLObj('tou1base', 		new tour1base(),	0.2,0.2) ;
	var tower1mur	= new atomicGLObj('tour1mur', 		new tour1mur(),		1.0,1.0) ;
	var tower1parape= new atomicGLObj('tour1parape', 	new tour1parape(),	1.0,1.0) ;
	var tower1sol	= new atomicGLObj('tour1sol', 		new tour1sol(),		1.0,1.0) ;
	var tower1toit 	= new atomicGLObj('tour1toit', 		new tour1toit(),	1.0,1.0) ;

	var wall2base	= new atomicGLObj('wall1base', 		new mur2base(),		0.2,0.2) ;
	var wall2stone = new atomicGLObj('wall2stone', 		new mur2pierre(),	1.0,1.0) ;
	var wall2wood	= new atomicGLObj('wall2wood', 		new mur2bois(),		1.0,1.0) ;
	var wall2roof 	= new atomicGLObj('wall2roof', 		new mur2toit(),		1.0,1.0) ;

	var house1mur	= new atomicGLObj('h1mur', 			new maison1mur(),	0.2,0.2) ;
	var house1sol 	= new atomicGLObj('h1sol', 			new maison1sol(),	1.0,1.0) ;
	var house1stone	= new atomicGLObj('h1stone', 		new maison1stone(),	1.0,1.0) ;
	var house1stone2= new atomicGLObj('h1stone2', 		new maison1stone2(),1.0,1.0) ;
	var house1toit 	= new atomicGLObj('h1roof', 		new maison1toit(),	1.0,1.0) ;
	var maison1wood = new atomicGLObj('h1wood', 		new maison1wood(),	1.0,1.0) ;

	var donjon1Base		= new atomicGLObj('donjon1Base', 		new donjonBase(),	0.2,0.2) ;
	var donjon1Bois 	= new atomicGLObj('donjon1Bois', 		new donjonBois(),	1.0,1.0) ;
	var donjon1Fenetre	= new atomicGLObj('donjon1Fenetre', 	new donjonFenetre(),1.0,1.0) ;
	var donjon1Mur	 	= new atomicGLObj('donjon1Mur', 		new donjonMur(),	1.0,1.0) ;
	var donjon1Sol 		= new atomicGLObj('donjon1Sol', 		new donjonSol(),	1.0,1.0) ;
	var donjon1Toiture 	= new atomicGLObj('donjon1Toiture', 	new donjonToiture(),1.0,1.0) ;
	
	var palais1		= new atomicGLObj('palais1', 		new palais_v01_bois_parquet(),	1.0,1.0) ;
	var palais2		= new atomicGLObj('palais2', 		new palais_v01_bois_poutre(),	1.0,1.0) ;
	var palais3		= new atomicGLObj('palais3', 		new palais_v01_decors(),		1.0,1.0) ;
	var palais4		= new atomicGLObj('palais4', 		new palais_v01_mur(),			1.0,1.0) ;
	var palais5		= new atomicGLObj('palais5', 		new palais_v01_terrase(),		1.0,1.0) ;
	var palais6		= new atomicGLObj('palais6', 		new palais_v01_toiture(),		1.0,1.0) ;
	
	var water 			= new atomicGLxzPlane("water",15,50,200,2,15.0,10.0);

	// animation
	var Yangle = 0.0 ;
	var waveTime = 0.0 ;
	

	//webGLStart
	function webGLStart() {
	// init
	// -----------------------------
		// recover penGL canvas 
		var canvas = document.getElementById("oglcanvas");

		// init OpenGL context
		agl.initGL(canvas,[0.15,0.1,0.5]);
		
		// light
		//agl.pushLight([-1000.0, 1000.0, 1000.0],[1.0,0.8,0.8]); // position, color
		agl.pushLight([+1000.0, 500.0, +500.0],[1.0,0.8,0.8]); // position, color
		//agl.ambientLightColor = [0.15,0.15,0.20];	// color
		agl.ambientLightColor = [0.1,0.05,0.0];	// color

		// init Matrix Stack
		ams.initMatrix(agl,45); // fov = 45 degrees
		
		// texture
		test 				=  	new atomicGLTexture("texture/test.png","color",agl);
		test_normal 		=  	new atomicGLTexture("texture/normal.png","color",agl);		
		
		sable1 				=  	new atomicGLTexture("texture/sable1.png","color",agl);
		herbe1 				=  	new atomicGLTexture("texture/herbe1.png","color",agl);

		mur_pierre1 		=  	new atomicGLTexture("texture/mur_pierre1.png","color",agl);
		mur_pierre1_normal 	=  	new atomicGLTexture("texture/mur_pierre1_normal.png","color",agl);
		
		mur2	 			=  	new atomicGLTexture("texture/mur2.png","color",agl);
		mur2_normal 		=  	new atomicGLTexture("texture/mur2_normal.png","color",agl);
		
		mur3 				=  	new atomicGLTexture("texture/mur3.png","color",agl);
		mur3_normal 		=  	new atomicGLTexture("texture/mur3_normal.png","color",agl);
		
		toit1 				=  	new atomicGLTexture("texture/toit1.png","color",agl);
		toit1_normal		=  	new atomicGLTexture("texture/toit1_normal.png","color",agl);

		bois1 				=  	new atomicGLTexture("texture/bois1.png","color",agl);

		pave2  				=  	new atomicGLTexture("texture/pave2.png","color",agl);
		pave2_normal  		=  	new atomicGLTexture("texture/pave2_normal.png","color",agl);
		
		pierre2 			= 	new atomicGLTexture("texture/pierre2.png","color",agl);
		pierre2_normal 		= 	new atomicGLTexture("texture/pierre2_normal.png","color",agl);

		pierre3 			= 	new atomicGLTexture("texture/pierre3.png","color",agl);
		pierre3_normal 		= 	new atomicGLTexture("texture/pierre3_normal.png","color",agl);

		sol3 				= 	new atomicGLTexture("texture/sol3.png","color",agl);

		eau1 				=	new atomicGLTexture("texture/eau1.png","color",agl);

		marbre1 			=	new atomicGLTexture("texture/marbre1.png","color",agl);

		bois2 				=	new atomicGLTexture("texture/bois2.png","color",agl);

		sol5 				=	new atomicGLTexture("texture/sol5.png","color",agl);

		sol4 				= 	new atomicGLTexture("texture/sol4.png","color",agl);
		sol4_normal 		= 	new atomicGLTexture("texture/sol4_normal.png","color",agl);
		
		toit2 				= 	new atomicGLTexture("texture/toit2.png","color",agl);
		toit2_normal 		= 	new atomicGLTexture("texture/toit2_normal.png","color",agl);

		skyTex 				= 	new atomicGLTexture("texture/skybox_texture.png","color",agl);
				
		// -------------------------------------------------
		// load shaders and push shader in context	
		textProg 		= new atomicGLShader("texture", agl,"frag_texture", "vertex_texture" ,1,0);
		textProgId		= agl.pushProgram(textProg);

		wtextProg 		= new atomicGLwaveShader("wave_texture", agl,"frag_texDiff", "vertex_wave" ,1,1);
		wtextProgId		= agl.pushProgram(wtextProg);

		texDiffProg 	= new atomicGLShader("diffuse-texture", agl,"frag_texDiff", "vertex_texDiff" ,1,1);
		texDiffProgId	= agl.pushProgram(texDiffProg);

		texDiffNormalMapProg 		= new atomicGLShader("diffuse-texture", agl,"frag_texDiffNormalMap", "vertex_texDiffNormalMap" ,2,1);
		texDiffNormalMapProgId		= agl.pushProgram(texDiffNormalMapProg);
		// --------------------------------------------------------
		// wave param
		wtextProg.A0 = [0.20,1.0,1.0];
		wtextProg.A1 = [0.20,2.0,1.0]; 
		wtextProg.A2 = [0.10,3.0,1.0]; 
		wtextProg.A3 = [0.10,4.0,1.0]; 
		wtextProg.xRange = [-5.0,5.0]; 
		// wave animation 
		wtextProg.wTime = 0.0 ;	
		
		// -------------------------------------------------
		sky.pushTexture(skyTex);		
		sky.initGLBuffers(agl);
		// -------------------------------------------------
		// environment
		ground_grass.pushTexture(herbe1); 
		ground_grass.initGLBuffers(agl); 
		
		ground_road.pushTexture(sol4); 					
		ground_road.pushTexture(sol4_normal);
		ground_road.initGLBuffers(agl);
 		
		ground_wall.pushTexture(mur_pierre1); 			
		ground_wall.pushTexture(mur_pierre1_normal); 
		ground_wall.initGLBuffers(agl); 
		
		ground_sand.pushTexture(sable1); 	
		ground_sand.initGLBuffers(agl); 	

		// house1
		house1mur.pushTexture(mur3);
		house1mur.pushTexture(mur3_normal);
		house1mur.initGLBuffers(agl);
	 
		house1sol.pushTexture(sol3); 
		house1sol.initGLBuffers(agl); 
	 
		house1stone.pushTexture(mur_pierre1);	
		house1stone.pushTexture(mur_pierre1_normal);	
		house1stone.initGLBuffers(agl);
	 
		house1stone2.pushTexture(mur2); 
		house1stone2.pushTexture(mur2_normal); 
		house1stone2.initGLBuffers(agl); 
	 
		house1toit.pushTexture(toit1); 	
		house1toit.pushTexture(toit1_normal);	
		house1toit.initGLBuffers(agl); 
	 
		maison1wood.pushTexture(bois1); 		
		maison1wood.initGLBuffers(agl); 		
		
		// house 3: texture and init
		house3.pushTexture(mur_pierre1);
		house3.pushTexture(mur_pierre1_normal); 		
		house3.initGLBuffers(agl);
		
		house3roof.pushTexture(toit1); 
		house3roof.pushTexture(toit1_normal); 		
		house3roof.initGLBuffers(agl);
		
		house3wood.pushTexture(bois1); 			
		house3wood.initGLBuffers(agl);
		
		// bridge
		bridge1stone.pushTexture(mur_pierre1);
		bridge1stone.pushTexture(mur_pierre1_normal); 	
		bridge1stone.initGLBuffers(agl);
		
		bridge1top.pushTexture(pave2); 			
		bridge1top.pushTexture(pave2_normal); 			
		bridge1top.initGLBuffers(agl);
		
		// tower
		tower1base.pushTexture(pierre3);		
		tower1base.pushTexture(pierre3_normal);		
		tower1base.initGLBuffers(agl);
		
		tower1mur.pushTexture(mur_pierre1);
		tower1mur.pushTexture(mur_pierre1_normal);		
		tower1mur.initGLBuffers(agl);
		
		tower1parape.pushTexture(bois1);		
		tower1parape.initGLBuffers(agl);
		
		tower1sol.pushTexture(sol3);			
		tower1sol.initGLBuffers(agl);
		
		tower1toit.pushTexture(toit1);			
		tower1toit.pushTexture(toit1_normal);			
		tower1toit.initGLBuffers(agl);
		
		// wall
		wall2base.pushTexture(pierre3) ;
		wall2base.pushTexture(pierre3_normal) ;
		wall2base.initGLBuffers(agl);
		
		wall2stone.pushTexture(mur_pierre1);
		wall2stone.pushTexture(mur_pierre1_normal);	
		wall2stone.initGLBuffers(agl);
		
		wall2wood.pushTexture(bois1);			
		wall2wood.initGLBuffers(agl);
		
		wall2roof.pushTexture(toit1);
		wall2roof.pushTexture(toit1_normal);
		
		wall2roof.initGLBuffers(agl);
		
		// 	water
		water.pushTexture(eau1) ;
		water.initGLBuffers(agl);
		
		// donjon
		donjon1Base.pushTexture(pierre3)		
		donjon1Base.pushTexture(pierre3_normal)		
		donjon1Base.initGLBuffers(agl);	
		
		donjon1Bois.pushTexture(bois1) 	
		donjon1Bois.initGLBuffers(agl); 	

		donjon1Fenetre.pushTexture(marbre1)
		donjon1Fenetre.initGLBuffers(agl);

		donjon1Mur.pushTexture(mur_pierre1)	 	
		donjon1Mur.pushTexture(mur_pierre1_normal)	 	
		donjon1Mur.initGLBuffers(agl);	 	

		donjon1Sol.pushTexture(sol3)				
		donjon1Sol.initGLBuffers(agl); 		

		donjon1Toiture.pushTexture(toit1)
		donjon1Toiture.pushTexture(toit1_normal)
		donjon1Toiture.initGLBuffers(agl);
		
		// palais
		palais1.pushTexture(bois2);	
		palais1.initGLBuffers(agl);	
		
		palais2.pushTexture(bois1);	
		palais2.initGLBuffers(agl);	
		
		palais3.pushTexture(sol5);	
		palais3.initGLBuffers(agl);	
		
		palais4.pushTexture(mur_pierre1);
		palais4.pushTexture(mur_pierre1_normal);	
		palais4.initGLBuffers(agl);	
		
		palais5.pushTexture(sol4);
		palais5.pushTexture(sol4_normal);	
		palais5.initGLBuffers(agl);	
		
		palais6.pushTexture(toit2);	
		palais6.pushTexture(toit2_normal);	
		palais6.initGLBuffers(agl);	
		
		// start the animation
		nextFrame();
	}
		
	// draw
	// -----------------------------
	function sceneDraw(){
		agl.initDraw();
		
		// global transform
		// ------------------------------
		// push matrix
		ams.mvPushMatrix();
		// position & orientation	

				// push matrix
				ams.mvPushMatrix();
					// position & orientation
					ams.mvTranslate(0.0,0.0,0.0);
					ams.mvRotate(cam.phi,[1,0,0]);
					ams.mvRotate(cam.theta,[0,1,0]);

					// draw
					sky.draw(agl,ams,textProgId); 	
					// pop matrix
				ams.mvPopMatrix();	
		
					ams.mvRotate(cam.phi,[1,0,0]);
					ams.mvRotate(cam.theta,[0,1,0]);
					ams.mvTranslate(-cam.xc,-cam.yc,-cam.zc);

				
				// env
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
					// position & orientation
					ams.mvTranslate(0.0,0.0,0.0);

					// draw
					ground_road.draw(agl,ams,texDiffNormalMapProgId);
					ground_wall.draw(agl,ams,texDiffNormalMapProgId); 
					ground_sand.draw(agl,ams,texDiffProgId); 
					ground_grass.draw(agl,ams,texDiffProgId); 	
					
					// pop matrix
				ams.mvPopMatrix();	
				 
				// tower
				// ---------------------------------
				// push matrix
				ams.mvPushMatrix();
					// position & orientation
					ams.mvTranslate(-10.0,0,-110);
					// draw
					tower1base.draw(agl,ams,texDiffNormalMapProgId);
					tower1mur.draw(agl,ams,texDiffNormalMapProgId);
					tower1parape.draw(agl,ams,texDiffProgId);
					tower1sol.draw(agl,ams,texDiffProgId);
					tower1toit.draw(agl,ams,texDiffNormalMapProgId);					
					
					ams.mvTranslate(15.0,0,00);
					// draw
					tower1base.draw(agl,ams,texDiffNormalMapProgId);
					tower1mur.draw(agl,ams,texDiffNormalMapProgId);
					tower1parape.draw(agl,ams,texDiffProgId);
					tower1sol.draw(agl,ams,texDiffProgId);
					tower1toit.draw(agl,ams,texDiffNormalMapProgId);
					// wall
					// push matrix
					ams.mvPushMatrix();
						// position & orientation
						ams.mvTranslate(4.4,0,-1.0);
						// draw
						wall2base.draw(agl,ams,texDiffNormalMapProgId);
						wall2stone.draw(agl,ams,texDiffNormalMapProgId);
						wall2wood.draw(agl,ams,texDiffProgId);
						wall2roof.draw(agl,ams,texDiffNormalMapProgId);
						// next part
						ams.mvTranslate(19.5,0,0.0);
						// draw
						wall2base.draw(agl,ams,texDiffNormalMapProgId);
						wall2stone.draw(agl,ams,texDiffNormalMapProgId);
						wall2wood.draw(agl,ams,texDiffProgId);
						wall2roof.draw(agl,ams,texDiffNormalMapProgId);
					// pop matrix
					ams.mvPopMatrix();
					// draw
				// pop matrix
				ams.mvPopMatrix();				
			
				// house1
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
					// position & orientation
					ams.mvTranslate(4.0,0.05,-80.0);

					// draw
					house1mur.draw(agl,ams,texDiffNormalMapProgId);
					house1sol.draw(agl,ams,texDiffProgId); 
					house1stone.draw(agl,ams,texDiffNormalMapProgId);
					house1stone2.draw(agl,ams,texDiffNormalMapProgId); 
					house1toit.draw(agl,ams,texDiffNormalMapProgId); 
					maison1wood.draw(agl,ams,texDiffProgId); 	
					
					// pop matrix
				ams.mvPopMatrix();				


				// house3 and bridge
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
					// position & orientation
					ams.mvTranslate(15.0,0.05,-75);
					ams.mvRotate(-90.0,[0,1,0]);
					
					// draw
					house3.draw(agl,ams,texDiffNormalMapProgId);
					house3roof.draw(agl,ams,texDiffNormalMapProgId);
					house3wood.draw(agl,ams,texDiffProgId);
					
					// pop matrix
				ams.mvPopMatrix();

				// push matrix
				ams.mvPushMatrix();
					// position & orientation
					ams.mvTranslate(0.0,0.1,0.0);					
					bridge1stone.draw(agl,ams,texDiffNormalMapProgId);
					bridge1top.draw(agl,ams,texDiffNormalMapProgId);
					
					// pop matrix
				ams.mvPopMatrix();
			
				// donjon
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
	
					// position & orientation
					ams.mvTranslate(-10.0,0.05,-40.0);		
					ams.mvRotate(90.0,[0,1,0]);						
					donjon1Base.draw(agl,ams,texDiffNormalMapProgId);	
					donjon1Bois.draw(agl,ams,texDiffProgId);
					donjon1Fenetre.draw(agl,ams,texDiffProgId);	
					donjon1Mur.draw(agl,ams,texDiffNormalMapProgId);	 				
					donjon1Sol.draw(agl,ams,texDiffProgId);		
					donjon1Toiture.draw(agl,ams,texDiffNormalMapProgId);			
			
				// pop matrix
				ams.mvPopMatrix();	

				// donjon2
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
	
					// position & orientation
					ams.mvTranslate(10.0,0.05,22.0);		
					ams.mvRotate(-180.0,[0,1,0]);						
					donjon1Base.draw(agl,ams,texDiffNormalMapProgId);	
					donjon1Bois.draw(agl,ams,texDiffProgId);
					donjon1Fenetre.draw(agl,ams,texDiffProgId);	
					donjon1Mur.draw(agl,ams,texDiffNormalMapProgId);	 				
					donjon1Sol.draw(agl,ams,texDiffProgId);		
					donjon1Toiture.draw(agl,ams,texDiffNormalMapProgId);			
			
				// pop matrix
				ams.mvPopMatrix();	
				
				// donjon3
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
	
					// position & orientation
					ams.mvTranslate(45.0,0.05,-112.0);		
					ams.mvRotate(-90.0,[0,1,0]);						
					donjon1Base.draw(agl,ams,texDiffNormalMapProgId);	
					donjon1Bois.draw(agl,ams,texDiffProgId);
					donjon1Fenetre.draw(agl,ams,texDiffProgId);	
					donjon1Mur.draw(agl,ams,texDiffNormalMapProgId);	 				
					donjon1Sol.draw(agl,ams,texDiffProgId);		
					donjon1Toiture.draw(agl,ams,texDiffNormalMapProgId);			
			
				// pop matrix
				ams.mvPopMatrix();	
				
				// palais
				// ---------------------------------------
				// push matrix
				ams.mvPushMatrix();
	
					// position & orientation
					ams.mvTranslate(-15.0,0.05,-70.0);		
					ams.mvRotate(0.0,[0,1,0]);					
					palais1.draw(agl,ams,texDiffProgId);	
					palais2.draw(agl,ams,texDiffProgId);
					palais3.draw(agl,ams,texDiffProgId);	
					palais4.draw(agl,ams,texDiffNormalMapProgId);	 				
					palais5.draw(agl,ams,texDiffNormalMapProgId);		
					palais6.draw(agl,ams,texDiffNormalMapProgId);			
			
				// pop matrix
				ams.mvPopMatrix();			
			

		// ---------------------------------------	
		// pop matrix
		ams.mvPopMatrix();
	}
	
	// nextFrame
	// -----------------------------
    function nextFrame() {
		handleKeys();
        requestAnimFrame(nextFrame);
        sceneDraw();
        animate();
    }
    
    // animate
    // ------------------------------
    function animate(){
    	// increase time
    	sceneClock.tick() ;
    	Yangle = Yangle + 0.01*sceneClock.get();
		waveTime = waveTime + 0.005*sceneClock.get();
    	wtextProg.wTime = waveTime ;
    }
	
	// keyboard
	// --------------------------------
	function handleKeyDown(event) 	{ currentlyPressedKeys[event.keyCode] = true;}
	function handleKeyUp(event) 	{currentlyPressedKeys[event.keyCode] = false;}

	function handleKeys() {
		if (Math.abs(mouseX)>0.1){
			cam.turnright(1.0*(mouseX*mouseX*mouseX));
		}
		cam.turnup(45*mouseY);
		if (currentlyPressedKeys[67]) // (C) debug
		{
			// debug 
			console.log('atomicGL - Rémi COZOT - 2015');
		}				
		if (currentlyPressedKeys[68]) // (D) Right
		{
			// debug 
			cam.right();		}
		if (currentlyPressedKeys[81]) // (Q) Left 
		{		
			// debug 
			cam.left();			//
		}
		if (currentlyPressedKeys[90]) // (Z) Up
		{
			// debug 
			cam.up();			//
		}
		if (currentlyPressedKeys[83]) // (S) Down 
		{
			// debug 
			cam.down();			//
		}
	}
	
	// mouse
	// ------------------------------
	function onDocumentMouseMove( event ) {
		omouseX = mouseX ;
		mouseX = ( event.clientX - windowHalfX ) / windowHalfX;
		mouseY = ( event.clientY - windowHalfY ) / windowHalfY;
	}

</script>
</head>

<body onload="webGLStart();">
	<br>
    <canvas id="oglcanvas" style="border: none;" width="1600" height="900"></canvas>
	<br>
</body></html>