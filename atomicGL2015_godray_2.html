<html>
<head>
	<title>atomicGL DEBUG </title>
	<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

	<script type="text/javascript" src="gltp1_fichiers/glMatrix-0.js"></script>
	<script type="text/javascript" src="gltp1_fichiers/webgl-utils.js"></script>

	<!-- ATOMICGL ENGINE -->
	<!-- load "modules" -->
	<script type="text/javascript" src="atomicGLContext.js"></script>
	<script type="text/javascript" src="atomicGLMatrixStack.js"></script>
	
	<script type="text/javascript" src="atomicGLClock.js"></script>

	<script type="text/javascript" src="atomicGLShader.js"></script>
	<script type="text/javascript" src="atomicGLwaveShader.js"></script>

	<script type="text/javascript" src="atomicGLCube.js"></script>
	<script type="text/javascript" src="atomicGLxyPlane.js"></script>
	<script type="text/javascript" src="atomicGLxzPlane.js"></script>
	<script type="text/javascript" src="atomicGLSphere.js"></script>





<script id="vertex_GodRay" type="x-shader/x-vertex">
	// vertex shader
	
attribute vec2 pos; 

void main() {

 gl_Position = vec4(pos.xy,0.0,.3);

  }

</script>
	<script id="frag_GodRay" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

void mainImage( out vec4 c,  in vec2 f );

const vec2 sunPos = vec2(0.5);
const vec3 sunColor = vec3(1.,1.,1.0);

const float sunSize = .1;
const float godrayReach = .3;
const int godrayIter = 32;
const float godrayIntensity = .05;
const float godrayStep = (sunSize/2.)/float(godrayIter);


const vec3 backgroundColor = vec3(.1);

const vec2 occlusionSize = vec2(.1);
vec2 occlusionLoc =vec2(2.5);// iMouse.xy/iResolution.xy;


float occlusionMap(in vec2 uv) {
    float d = length(max(abs(uv-occlusionLoc)-vec2(occlusionSize),0.0));
    d = max(-(length(mod(uv-occlusionLoc,occlusionSize*.5)-occlusionSize*.25)-occlusionSize.x*.5),d);
    return floor(1.03-d);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
	vec2 uv = fragCoord.xy / vec2(200);
    
   // if (iMouse.w < 1.) {
        occlusionLoc = vec2(sin(.6)*.2+.5,cos(.76)*.2+.5);
    //}
    
    float cl = occlusionMap(uv);
    vec2 sunDir = sunPos-uv;
    float sunLen = length(sunDir);
    if (sunLen < sunSize) {
        fragColor = vec4(mix(sunColor,vec3(cl*.3),cl),1.);
        return;
    }
    vec3 c = backgroundColor;
    
    float cb;
   	c = mix(c,vec3(cl*.3),cl);
    cl = 0.;
    if (sunLen < godrayReach) {
        
        sunDir = normalize(sunDir);
        uv += sunDir*max(0.,(sunLen-sunSize));
        sunLen = 1.-sunLen/godrayReach;
        int maxIter = int(sunLen*float(godrayIter));
        
        for (int i = 0; i < godrayIter; i++) {
            
            cl += max(0.,1.-occlusionMap(uv))*sunLen;
                
            if (i > maxIter) {
                break;
            }
            
            uv += sunDir*godrayStep;
        }
        
        cl *= godrayIntensity;
        c += min(1.,cl)*sunColor;
    }
    
    fragColor = vec4(c,1.);
}
void main( void ){
	vec4 color = vec4(0.0,0.0,0.0,1.0);
	mainImage( color, gl_FragCoord.xy );
	color.w = 1.0;
	gl_FragColor = color;
}



</script>

	<!-- SHADER: diffus per fragment -->
	<!-- diffuse shader -->
	<script id="vertex_diffuse" type="x-shader/x-vertex">
	// vertex shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// attributes inputs  (vertex arrays)
		attribute vec3 aVertexPosition;
		attribute vec3 aVertexNormal;
		attribute vec3 aVertexColor;

	// uniform matrices
		uniform mat4 uMVMatrix;
		uniform mat4 uPMatrix;
		uniform mat3 uNMatrix;

	// output (to fragment shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;

	void main(void) {
		// model -> view 
		vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;
		// vNormal
		vNormal = uNMatrix * aVertexNormal;	
		// vcolor
		vcolor = aVertexColor;
	}
</script>
<script id="frag_diffuse" type="x-shader/x-fragment">
	#ifdef GL_ES
		precision highp float;
	#endif

	// fragment shader
	// ------------------------------------------------------
	// diffuse shader
	// per fragment 
	// lights nb: 1
	// ------------------------------------------------------

	// varying input (output of the vertex shader)
		varying vec4 vPosition;
		varying vec3 vNormal;
		varying vec3 vcolor;
		
	// lights

		//point light ie omni dir:  location, color
		uniform vec3 uPointLightPosition0;
		uniform vec3 uPointLightColor0;


	// local constant
		// Kd: diffuse coeff
		float Kd = 1.0 ;
	
	// main
    void main(void) {	
		// light direction
		vec3 lightDirection = normalize(uPointLightPosition0 - vPosition.xyz);

		// eye direction
		vec3 eyeDirection = normalize(-vPosition.xyz);

		// normalize normal
		vec3 normal = normalize(vNormal);
		//  diffuse term
		float diffuseLightWeight = max(dot(normal, lightDirection), 0.0);
			
		// light color
         vec3 lightColor =  Kd*diffuseLightWeight*(uPointLightColor0)*vcolor  ;

        gl_FragColor = vec4(lightColor,1.0);
    }
</script>

	<!-- ATOMICGL ENGINE -->
	<!-- create objects -->
	<!-- wegGLStart function (required) -->
	<script type="text/javascript">
	//------------------------------------------------------------------------------

	// OpenGL context
	var agl = new atomicGLContext();
	
	// clock
	var sceneClock =new atomicGLClock() ;

	// matrix stack
	var ams =new atomicGLMatrixStack();


	// diffus
	var diffusProg ;
	var diffusProgId ;
	
	var uTime = 1.0 ;

	var sphere 		= new atomicGLSphere("sphere",0.5,64,64);
	var sphere1 		= new atomicGLSphere("sphere",0.5,64,64);

	// animation
	var colorCubeYangle = 0.0 ;
	

	//webGLStart
	function webGLStart() {
	// init
	// -----------------------------
		// recover penGL canvas 
		var canvas = document.getElementById("oglcanvas");

		// init OpenGL context
		agl.initGL(canvas,[0.0,0.0,0.0]);
		
		// light
	//	agl.pushLight([1.0,-2.1,-20.0],[1.0,1.0,1.0]); // position, color
		agl.pushLight([1.1,-2.2,-20.0],[1.0,.0,.0]); // position, color
	//	agl.pushLight([2.2,10,-25.0],[1.0,1.0,1.0]); // position, color

		//agl.ambientLightColor = [0.01,0.01,0.2];	// color

		// init Matrix Stack
		ams.initMatrix(agl,45); // fov = 45 degrees

		// load shaders
		diffusProg 		= new atomicGLShader("diffus", agl,"frag_diffuse", "vertex_diffuse" ,false,1);
		
		vertexGodRayProg = new atomicGLShader("godRay", agl,"frag_GodRay", "vertex_GodRay" ,false,1);


		// push shader in context
		diffusProgId 		= agl.pushProgram(diffusProg);
	
		GodRayProgId 	= agl.pushProgram(vertexGodRayProg);

		// sphere
		sphere.setFaceColor("All",[1.0,1.0,1.0]);
		sphere.initGLBuffers(agl);
		sphere1.initGLBuffers(agl)
		// start the animation
		nextFrame();
	}
		
	// draw
	// -----------------------------
	function sceneDraw(){
		agl.initDraw();

		// global transform
		// ------------------------------
		// push matrix
		ams.mvPushMatrix();
		// position & orientation	

			ams.mvTranslate(0,-20,-50);
			//ams.mvTranslate(0,-15,-30);

		
			// sphere
			// ---------------------------------------
			// push matrix
			ams.mvPushMatrix();
				// position & orientation
				ams.mvTranslate(0.0,0.5,0);
				// draw
				sphere.draw(agl,ams,diffusProgId);
			// pop matrix
			ams.mvPopMatrix();
					ams.mvTranslate(0,-2,-20);
			ams.mvRotate(20,[1,0,0]);
			//ams.mvTranslate(0,-15,-30);
		
		
			// sphere
			// ---------------------------------------
			// push matrix
			ams.mvPushMatrix();
			ams.mvPopMatrix();

				ams.mvTranslate(0.0,0.5,0);
				// position & orientation
				// draw
				sphere1.draw(agl,ams,GodRayProgId);
			// pop matrix
							ams.mvTranslate(0.0,-2,-25);

		// ---------------------------------------	
		// pop matrix
		ams.mvPopMatrix();
	}
	
	// nextFrame
	// -----------------------------
    function nextFrame() {
        requestAnimFrame(nextFrame);
        sceneDraw();
        animate();
    }
    
    // animate
    // ------------------------------
    function animate(){
    	// increase time
    	sceneClock.tick() ;
    	colorCubeYangle = colorCubeYangle + 0.1*sceneClock.get();
    }

</script>
</head>

<body onload="webGLStart();">
	<br>
    <canvas id="oglcanvas" style="border: none;" width="800" height="600"></canvas>
	<br>
</body></html>